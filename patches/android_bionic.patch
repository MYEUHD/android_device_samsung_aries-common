From 8ecefef4bb0805335f7740bc8965605f7701c4bd Mon Sep 17 00:00:00 2001
From: xc-racer99 <xc-racer2@live.ca>
Date: Tue, 12 Apr 2016 19:02:17 -0700
Subject: [PATCH 1/4] bionic: Restore non-pie support

---
 linker/Android.mk | 4 ++++
 linker/linker.cpp | 2 ++
 2 files changed, 6 insertions(+)

diff --git a/linker/Android.mk b/linker/Android.mk
index 7a9b5d9..9f578c9 100644
--- a/linker/Android.mk
+++ b/linker/Android.mk
@@ -49,6 +49,10 @@ ifeq ($(TARGET_IS_64_BIT),true)
 LOCAL_CPPFLAGS += -DTARGET_IS_64_BIT
 endif
 
+ifeq ($(TARGET_ENABLE_NON_PIE_SUPPORT),true)
+    LOCAL_CFLAGS += -DENABLE_NON_PIE_SUPPORT
+endif
+
 # We need to access Bionic private headers in the linker.
 LOCAL_CFLAGS += -I$(LOCAL_PATH)/../libc/
 
diff --git a/linker/linker.cpp b/linker/linker.cpp
index d3ac1d0..6a5967f 100644
--- a/linker/linker.cpp
+++ b/linker/linker.cpp
@@ -3211,11 +3211,13 @@ static ElfW(Addr) __linker_init_post_relocation(KernelArgumentBlock& args, ElfW(
   }
   si->dynamic = nullptr;
 
+#ifndef ENABLE_NON_PIE_SUPPORT
   ElfW(Ehdr)* elf_hdr = reinterpret_cast<ElfW(Ehdr)*>(si->base);
   if (elf_hdr->e_type != ET_DYN) {
     __libc_format_fd(2, "error: only position independent executables (PIE) are supported.\n");
     exit(EXIT_FAILURE);
   }
+#endif
 
   // Use LD_LIBRARY_PATH and LD_PRELOAD (but only if we aren't setuid/setgid).
   parse_LD_LIBRARY_PATH(ldpath_env);
-- 
2.1.4


From 9ef1301a8889367002df56701d64cddd4f8d0bfc Mon Sep 17 00:00:00 2001
From: xc-racer99 <xc-racer2@live.ca>
Date: Wed, 16 Dec 2015 12:38:40 -0800
Subject: [PATCH 2/4] Revert "bionic: Remove prelink support"

Needed to load older RIL blobs.
This reverts commit 792df63bae3a71c529a977bab0189473aa837480.
---
 linker/Android.mk      |  4 ++++
 linker/linker_phdr.cpp | 45 ++++++++++++++++++++++++++++++++++++++++++++-
 linker/linker_phdr.h   |  9 ++++++++-
 3 files changed, 56 insertions(+), 2 deletions(-)

diff --git a/linker/Android.mk b/linker/Android.mk
index 9f578c9..95eb305 100644
--- a/linker/Android.mk
+++ b/linker/Android.mk
@@ -49,6 +49,10 @@ ifeq ($(TARGET_IS_64_BIT),true)
 LOCAL_CPPFLAGS += -DTARGET_IS_64_BIT
 endif
 
+ifeq ($(TARGET_NEEDS_BIONIC_PRELINK_SUPPORT),true)
+    LOCAL_CFLAGS += -DENABLE_PRELINK_SUPPORT
+endif
+
 ifeq ($(TARGET_ENABLE_NON_PIE_SUPPORT),true)
     LOCAL_CFLAGS += -DENABLE_NON_PIE_SUPPORT
 endif
diff --git a/linker/linker_phdr.cpp b/linker/linker_phdr.cpp
index 30118e3..8df6198 100644
--- a/linker/linker_phdr.cpp
+++ b/linker/linker_phdr.cpp
@@ -137,6 +137,9 @@ ElfReader::ElfReader(const char* name, int fd, off64_t file_offset, off64_t file
     : name_(name), fd_(fd), file_offset_(file_offset), file_size_(file_size),
       phdr_num_(0), phdr_mmap_(nullptr), phdr_table_(nullptr), phdr_size_(0),
       load_start_(nullptr), load_size_(0), load_bias_(0),
+#ifdef ENABLE_PRELINK_SUPPORT
+      required_base_(0),
+#endif
       loaded_phdr_(nullptr) {
 }
 
@@ -301,6 +304,38 @@ size_t phdr_table_get_load_size(const ElfW(Phdr)* phdr_table, size_t phdr_count,
   return max_vaddr - min_vaddr;
 }
 
+#ifdef ENABLE_PRELINK_SUPPORT
+typedef struct {
+    long mmap_addr;
+    char tag[4]; /* 'P', 'R', 'E', ' ' */
+} prelink_info_t;
+
+/* Returns the requested base address if the library is prelinked,
+ * and 0 otherwise.  */
+static ElfW(Addr) is_prelinked(int fd, const char *name)
+{
+    off_t sz = lseek(fd, -sizeof(prelink_info_t), SEEK_END);
+    if (sz < 0) {
+        DL_ERR("lseek() failed!");
+        return 0;
+    }
+
+    prelink_info_t info;
+    int rc = TEMP_FAILURE_RETRY(read(fd, &info, sizeof(info)));
+    if (rc != sizeof(info)) {
+        DL_ERR("Could not read prelink_info_t structure for `%s`\n", name);
+        return 0;
+    }
+
+    if (memcmp(info.tag, "PRE ", 4)) {
+        DL_ERR("`%s` is not a prelinked library\n", name);
+        return 0;
+    }
+
+    return (unsigned long)info.mmap_addr;
+}
+#endif
+
 // Reserve a virtual address range big enough to hold all loadable
 // segments of a program header table. This is done by creating a
 // private anonymous mmap() with PROT_NONE.
@@ -311,7 +346,9 @@ bool ElfReader::ReserveAddressSpace(const android_dlextinfo* extinfo) {
     DL_ERR("\"%s\" has no loadable segments", name_);
     return false;
   }
-
+#ifdef ENABLE_PRELINK_SUPPORT
+  required_base_ = is_prelinked(fd_, name_);
+#endif
   uint8_t* addr = reinterpret_cast<uint8_t*>(min_vaddr);
   void* start;
   size_t reserved_size = 0;
@@ -339,7 +376,13 @@ bool ElfReader::ReserveAddressSpace(const android_dlextinfo* extinfo) {
       return false;
     }
     int mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS;
+#ifndef ENABLE_PRELINK_SUPPORT
     start = mmap(mmap_hint, load_size_, PROT_NONE, mmap_flags, -1, 0);
+#else
+    if (required_base_ != 0)
+      mmap_flags |= MAP_FIXED;
+    start = mmap((void*)required_base_, load_size_, PROT_NONE, mmap_flags, -1, 0);
+#endif
     if (start == MAP_FAILED) {
       DL_ERR("couldn't reserve %zd bytes of address space for \"%s\"", load_size_, name_);
       return false;
diff --git a/linker/linker_phdr.h b/linker/linker_phdr.h
index 3affa66..db09d80 100644
--- a/linker/linker_phdr.h
+++ b/linker/linker_phdr.h
@@ -49,6 +49,9 @@ class ElfReader {
   size_t load_size() { return load_size_; }
   ElfW(Addr) load_bias() { return load_bias_; }
   const ElfW(Phdr)* loaded_phdr() { return loaded_phdr_; }
+#ifdef ENABLE_PRELINK_SUPPORT
+  ElfW(Addr) required_base() { return required_base_; }
+#endif
 
  private:
   bool ReadElfHeader();
@@ -77,7 +80,11 @@ class ElfReader {
   size_t load_size_;
   // Load bias.
   ElfW(Addr) load_bias_;
-
+#ifdef ENABLE_PRELINK_SUPPORT
+  // For prelinked libraries, mandatory load address of the first
+  // loadable segment. 0 otherwise.
+  ElfW(Addr) required_base_;
+#endif
   // Loaded phdr.
   const ElfW(Phdr)* loaded_phdr_;
 };
-- 
2.1.4


From e8f284f1bca12644428ca88f07e59c767d910cf0 Mon Sep 17 00:00:00 2001
From: xc-racer99 <xc-racer2@live.ca>
Date: Wed, 16 Dec 2015 16:59:32 -0800
Subject: [PATCH 3/4] linker: Fix prelink support

Use c++ casts, ignore set but unused variable

Change-Id: I041a61ffa904f2981fe2e9bdd194bb9b9d9286b4
---
 linker/Android.mk      | 1 +
 linker/linker_phdr.cpp | 4 ++--
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/linker/Android.mk b/linker/Android.mk
index 95eb305..b3bb80a 100644
--- a/linker/Android.mk
+++ b/linker/Android.mk
@@ -51,6 +51,7 @@ endif
 
 ifeq ($(TARGET_NEEDS_BIONIC_PRELINK_SUPPORT),true)
     LOCAL_CFLAGS += -DENABLE_PRELINK_SUPPORT
+    LOCAL_CPPFLAGS += -Wno-unused-but-set-variable
 endif
 
 ifeq ($(TARGET_ENABLE_NON_PIE_SUPPORT),true)
diff --git a/linker/linker_phdr.cpp b/linker/linker_phdr.cpp
index 8df6198..ddbf3cb 100644
--- a/linker/linker_phdr.cpp
+++ b/linker/linker_phdr.cpp
@@ -332,7 +332,7 @@ static ElfW(Addr) is_prelinked(int fd, const char *name)
         return 0;
     }
 
-    return (unsigned long)info.mmap_addr;
+    return static_cast<unsigned long>(info.mmap_addr);
 }
 #endif
 
@@ -381,7 +381,7 @@ bool ElfReader::ReserveAddressSpace(const android_dlextinfo* extinfo) {
 #else
     if (required_base_ != 0)
       mmap_flags |= MAP_FIXED;
-    start = mmap((void*)required_base_, load_size_, PROT_NONE, mmap_flags, -1, 0);
+    start = mmap(reinterpret_cast<void*>(required_base_), load_size_, PROT_NONE, mmap_flags, -1, 0);
 #endif
     if (start == MAP_FAILED) {
       DL_ERR("couldn't reserve %zd bytes of address space for \"%s\"", load_size_, name_);
-- 
2.1.4


From c19c8822bcad6de8135e6369c29d2b55ca8f8729 Mon Sep 17 00:00:00 2001
From: Flemmard <flemmard@gmail.com>
Date: Thu, 13 Nov 2014 00:12:22 +0100
Subject: [PATCH 4/4] bionic: Add flag to restore legacy mmap behavior

* Pre-lollipop mmap would not care whether offset was signed
  or unsigned.
* Lollipop adds 64-bit support which results in sign extension
  of offset, causing a negative offset when
  a positive offset > 2^31 is given.

Change-Id: I5d19d898fc131cf848217974915d1b466a474f99

Conflicts:
	libc/Android.mk
---
 libc/Android.mk      | 4 ++++
 libc/bionic/mmap.cpp | 7 ++++++-
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/libc/Android.mk b/libc/Android.mk
index f0c5e9f..26a97c3 100644
--- a/libc/Android.mk
+++ b/libc/Android.mk
@@ -611,6 +611,10 @@ ifneq ($(BOARD_MALLOC_ALIGNMENT),)
   libc_common_cflags += -DMALLOC_ALIGNMENT=$(BOARD_MALLOC_ALIGNMENT)
 endif
 
+ifeq ($(BOARD_USES_LEGACY_MMAP),true)
+  libc_common_cflags += -DLEGACY_MMAP
+endif
+
 # Define some common conlyflags
 libc_common_conlyflags := \
     -std=gnu99
diff --git a/libc/bionic/mmap.cpp b/libc/bionic/mmap.cpp
index 8f25a89..53e8b46 100644
--- a/libc/bionic/mmap.cpp
+++ b/libc/bionic/mmap.cpp
@@ -36,6 +36,11 @@
 extern "C" void*  __mmap2(void*, size_t, int, int, int, size_t);
 
 #define MMAP2_SHIFT 12 // 2**12 == 4096
+#ifdef LEGACY_MMAP
+#define TO_64(a) ((a) & 0x00000000ffffffff)
+#else
+#define TO_64(a) (a)
+#endif
 
 static bool kernel_has_MADV_MERGEABLE = true;
 
@@ -60,5 +65,5 @@ void* mmap64(void* addr, size_t size, int prot, int flags, int fd, off64_t offse
 }
 
 void* mmap(void* addr, size_t size, int prot, int flags, int fd, off_t offset) {
-  return mmap64(addr, size, prot, flags, fd, static_cast<off64_t>(offset));
+  return mmap64(addr, size, prot, flags, fd, TO_64(static_cast<off64_t>(offset)));
 }
-- 
2.1.4

